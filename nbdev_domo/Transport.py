# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/95_Transport.ipynb.

# %% auto 0
__all__ = ['TransportSync', 'TransportAsync']

# %% ../nbs/95_Transport.ipynb 3
from dataclasses import dataclass, field
from enum import Enum

from abc import abstractmethod

from typing import Optional, Union

from requests_toolbelt.utils import dump
import json

import requests
import aiohttp
import asyncio

from fastcore.basics import patch_to
from .ResponseGetData import ResponseGetData


# %% ../nbs/95_Transport.ipynb 5
class RequestTransport:
    """
    The `RequestTransport` abstract base class adds consistency to the transport methods with consistent methods for 
    generating headers, as well as generating requests from APIs.
    """

    def __init__(self, auth_header: Optional[dict] = None,  # optional API authentication header
                 # defalt timeout to prevent infinite loops
                 request_timeout: Optional[int] = 10
                 ):

        self.auth_header = auth_header
        self.request_timeout = request_timeout

    @abstractmethod
    def _request() -> ResponseGetData:
        """Because each library has their own request methods, _request will be implemented in the interface classes of RequestTransport"""
        pass

    def dump_response(self, response):
        data = dump.dump_all(response)
        return str(data.decode('utf-8'))

    @staticmethod
    def _obj_to_json(obj):
        return json.dumps(obj, default=str)

    def _headers_default_receive_json(self):
        headers = {'Accept': 'application/json'}
        if self.auth_header:
            headers.update(self.auth_header)
        return headers

    def _headers_receive_csv(self):
        headers = self._headers_default_receive_json()
        headers['Accept'] = 'text/csv'
        return headers

    def _headers_send_json(self):
        headers = self._headers_default_receive_json()
        headers['Content-Type'] = 'application/json'
        return headers

    def _headers_send_csv(self):
        headers = self._headers_default_receive_json()
        headers['Content-Type'] = 'text/csv'
        return headers

    def _headers_send_gzip(self):
        headers = self._headers_default_receive_json()
        headers['Content-Type'] = 'text/csv'
        headers['Content-Encoding'] = 'gzip'
        return headers


# %% ../nbs/95_Transport.ipynb 7
class HTTPMethod(Enum):
    """utility class used by RequestTransport to enumerate HTTP methods"""

    GET = 'GET'
    POST = 'POST'
    PUT = 'PUT'
    PATCH = 'PATCH'
    DELETE = 'DELETE'


# %% ../nbs/95_Transport.ipynb 8
# Each method establishes the appropriate headers before calling the request method.


@patch_to(RequestTransport)
def get(self, url, params=None, request_timeout: Optional[int] = None, session: Optional[aiohttp.ClientSession] = None):
    if request_timeout:
        self.request_timeout = request_timeout

    headers = self._headers_default_receive_json()
    return self._request(url, HTTPMethod.GET, headers, params, session=session)


@patch_to(RequestTransport)
def get_csv(self, url, params=None, request_timeout: Optional[int] = None, session: Optional[aiohttp.ClientSession] = None):
    if request_timeout:
        self.request_timeout = request_timeout

    headers = self._headers_receive_csv()
    return self._request(url, HTTPMethod.GET, headers, params, session=session)


@patch_to(RequestTransport)
def post(self, url, body, params=None, request_timeout: Optional[int] = None, session: Optional[aiohttp.ClientSession] = None) -> ResponseGetData:
    if request_timeout:
        self.request_timeout = request_timeout

    headers = self._headers_send_json()
    return self._request(url, HTTPMethod.POST, headers, params,
                         self._obj_to_json(body), session=session)


@patch_to(RequestTransport)
def put(self, url, body, request_timeout: Optional[int] = None, session: Optional[aiohttp.ClientSession] = None):
    if request_timeout:
        self.request_timeout = request_timeout

    headers = self._headers_send_json()
    return self._request(url, HTTPMethod.PUT, headers, {},
                         self._obj_to_json(body), session=session)


@patch_to(RequestTransport)
def put_csv(self, url, body, request_timeout: Optional[int] = None, session: Optional[aiohttp.ClientSession] = None):
    if request_timeout:
        self.request_timeout = request_timeout

    headers = self._headers_send_csv()
    return self._request(url, HTTPMethod.PUT, headers, {}, body, session=session)


@patch_to(RequestTransport)
def put_gzip(self, url, body, request_timeout: Optional[int] = None, session: Optional[aiohttp.ClientSession] = None):
    if request_timeout:
        self.request_timeout = request_timeout

    headers = self._headers_send_gzip()
    return self._request(url, HTTPMethod.PUT, headers, {}, body, session=session)


@patch_to(RequestTransport)
def patch(self, url, body, request_timeout: Optional[int] = None, session: Optional[aiohttp.ClientSession] = None):
    if request_timeout:
        self.request_timeout = request_timeout

    headers = self._headers_send_json()
    return self._request(url, HTTPMethod.PATCH, headers, {},
                         self._obj_to_json(body), session=session)


@patch_to(RequestTransport)
def delete(self, url, request_timeout: Optional[int] = None, session: Optional[aiohttp.ClientSession] = None):
    if request_timeout:
        self.request_timeout = request_timeout

    headers = self._headers_default_receive_json()
    return self._request(url, HTTPMethod.DELETE, headers, session=session)


# %% ../nbs/95_Transport.ipynb 10
class TransportSync(RequestTransport):
    def __init__(self, auth_header: Optional[dict] = None,  # for API Authentication
                 request_timeout: int = 10  # for default timeout to prevent infinite loops
                 ):
        super().__init__(auth_header=auth_header, request_timeout=request_timeout)

    def _request(self,
                 url: str,
                 method: HTTPMethod,
                 headers: dict,
                 params: dict = field(default_factory=dict),
                 body: Union[str, dict, None] = None, **kwargs
                 ):

        # self.logger.debug('{} {} {}'.format(method, url, body))

        request_args = {'method': method.value,
                        'url': url,
                        'headers': headers,
                        'params': params,
                        'data': body,
                        'stream': True}

        if self.request_timeout:
            request_args['timeout'] = self.request_timeout

        res = requests.request(**request_args)
        return ResponseGetData._from_requests_response(res=res, auth_header=self.auth_header)


# %% ../nbs/95_Transport.ipynb 14
class TransportAsync(RequestTransport):
    """wrapper for aiohttp.ClientSession and aiohttp.ClientResponse for handling asynchronous code execution.  In the event of request_timeout, will default to synchronous code execution via requests.request library"""

    def __init__(self,
                 # API Authentication header
                 auth_header: Optional[dict] = None,
                 request_timeout: int = 10,  # request timeout to prevent infinite loops
                 session: Optional[aiohttp.ClientSession] = None
                 ):

        self.session = session
        super().__init__(auth_header=auth_header, request_timeout=request_timeout)

    async def _request(self,
                       url: str,
                       method: HTTPMethod,
                       headers: dict,
                       params: dict = field(default_factory=dict),
                       body: Union[str, dict, None] = None,
                       session: Optional[aiohttp.ClientSession] = None,
                       ):

        session = session or self.session

        if session is None:
            is_close_session = True
            session = aiohttp.ClientSession()
        else:
            is_close_session = False

        # self.logger.debug('{} {} {}'.format(method, url, body))

        request_args = {'url': url,
                        'headers': headers,
                        'params': params,
                        'data': body}

        try:
            res = await getattr(session, method.value.lower())(
                timeout=aiohttp.ClientTimeout(total=self.request_timeout),
                **request_args)

            return await ResponseGetData._from_aiohttp_response(res, auth_header=self.auth_header)

        except asyncio.TimeoutError as e:
            print('defaulting to sync request.  TimeoutError')

            res = requests.request(
                method=method.value,
                timeout=self.request_timeout,
                **request_args)

            return ResponseGetData._from_requests_response(res, auth_header=self.auth_header)

        finally:
            if is_close_session:
                await session.close()

